import * as fs from 'fs/promises';
import * as path from 'path';
import { Compiler } from '../../src/lib/compiler/Compiler';
import { ReactFlowAdapter } from '../../src/lib/adapter/ReactFlowAdapter';

export interface ProjectOptions {
    name: string;
    path: string;
    runtime: 'nodejs' | 'bun';
    template: string;
}

export class ProjectGenerator {

    static async generate(options: ProjectOptions): Promise<void> {
        const projectPath = path.join(options.path, options.name);

        // 1. Create Structure
        await fs.mkdir(projectPath, { recursive: true });
        await fs.mkdir(path.join(projectPath, 'commands'), { recursive: true });
        await fs.mkdir(path.join(projectPath, 'events'), { recursive: true });
        await fs.mkdir(path.join(projectPath, 'handlers'), { recursive: true });
        await fs.mkdir(path.join(projectPath, 'slash_commands'), { recursive: true });

        // 2. Write Files

        // --- Root Files ---

        // package.json
        const packageJson = {
            name: options.name,
            version: "1.0.0",
            description: "",
            main: "index.js",
            scripts: {
                start: options.runtime === 'bun' ? "bun run index.js" : "node index.js",
                dev: options.runtime === 'bun' ? "bun run --watch index.js" : "nodemon index.js"
            },
            keywords: [],
            author: "",
            license: "ISC",
            dependencies: {
                "discord.js": "^14.14.1",
                "dotenv": "^16.3.1"
            },
            devDependencies: options.runtime === 'nodejs' ? {
                "nodemon": "^3.0.2"
            } : {}
        };
        await fs.writeFile(path.join(projectPath, 'package.json'), JSON.stringify(packageJson, null, 2));

        // .gitignore
        await fs.writeFile(path.join(projectPath, '.gitignore'), `node_modules\n.env\ndist\n`);

        // .env
        await fs.writeFile(path.join(projectPath, '.env'), `DISCORD_TOKEN=\nCLIENT_ID=\n`);

        const railgunProject = {
            "name": options.name,
            "version": "1.0.0",
            "railgunVersion": "1.0.0",
            "prefix": "!",
            "gatewayIntents": [
                "Guilds",
                "GuildMessages",
                "MessageContent"
            ]
        };
        await fs.writeFile(path.join(projectPath, 'railgun.config.json'), JSON.stringify(railgunProject));

        // index.js
        const indexJs = `require('dotenv').config();
const { Client, GatewayIntentBits, Collection } = require('discord.js');
const fs = require('fs');
const path = require('path');

// Load Config from railgun.config.json (JSON parse as Node doesn't native load .railgun)
const projectConfig = JSON.parse(fs.readFileSync(path.join(__dirname, 'railgun.config.json'), 'utf-8'));

const client = new Client({
    intents: projectConfig.gatewayIntents || ['Guilds', 'GuildMessages', 'MessageContent'],
});

// Load Compiled Logic (bot.js)
// This file is generated by the Railgun Compiler
try {
    require('./bot.js')(client);
} catch (err) {
    console.error("Failed to load bot logic (bot.js):", err);
}

// Load Handlers (Legacy Support for manual handlers)
const handlersPath = path.join(__dirname, 'handlers');
if (fs.existsSync(handlersPath)) {
    const handlerFiles = fs.readdirSync(handlersPath).filter(file => file.endsWith('.js'));
    for (const file of handlerFiles) {
        require(\`./handlers/\${file}\`)(client);
    }
}

client.login(process.env.DISCORD_TOKEN);
`;
        await fs.writeFile(path.join(projectPath, 'index.js'), indexJs);


        // --- Handlers ---

        // commandHandler.js
        const commandHandler = `const fs = require('fs');
const path = require('path');

module.exports = (client) => {
    client.commands = new Map();
    client.aliases = new Map();

    const commandsPath = path.join(__dirname, '../commands');

    if (!fs.existsSync(commandsPath)) return;

    // Read category folders
    const commandFolders = fs.readdirSync(commandsPath).filter(file => fs.statSync(path.join(commandsPath, file)).isDirectory());

    for (const folder of commandFolders) {
        const commandsPathFull = path.join(commandsPath, folder);
        const commandFiles = fs.readdirSync(commandsPathFull).filter(file => file.endsWith('.js'));

        for (const file of commandFiles) {
            const filePath = path.join(commandsPathFull, file);
            const command = require(filePath);

            if (command.name) {
                client.commands.set(command.name, command);

                if (command.aliases && Array.isArray(command.aliases)) {
                    command.aliases.forEach(alias => client.aliases.set(alias, command.name));
                }
            }
        }
    }

    // Also check root folder for commands not in categories
    const rootCommandFiles = fs.readdirSync(commandsPath).filter(file => file.endsWith('.js'));
    for (const file of rootCommandFiles) {
        const filePath = path.join(commandsPath, file);
        const command = require(filePath);
        if (command.name) {
            client.commands.set(command.name, command);
            if (command.aliases && Array.isArray(command.aliases)) {
                command.aliases.forEach(alias => client.aliases.set(alias, command.name));
            }
        }
    }
};
`;
        await fs.writeFile(path.join(projectPath, 'handlers', 'commandHandler.js'), commandHandler);

        // eventHandler.js
        const eventHandler = `const fs = require('fs');
const path = require('path');

module.exports = (client) => {
    const eventsPath = path.join(__dirname, '../events');
    
    if (!fs.existsSync(eventsPath)) return;

    const eventFiles = fs.readdirSync(eventsPath).filter(file => file.endsWith('.js'));

    for (const file of eventFiles) {
        const filePath = path.join(eventsPath, file);
        const event = require(filePath);
        
        if (event.once) {
            client.once(event.name, (...args) => event.execute(...args));
        } else {
            client.on(event.name, (...args) => event.execute(...args));
        }
    }
    
    // Support for subdirectories in events folder
    const eventFolders = fs.readdirSync(eventsPath).filter(file => fs.statSync(path.join(eventsPath, file)).isDirectory());
    for (const folder of eventFolders) {
        const files = fs.readdirSync(path.join(eventsPath, folder)).filter(file => file.endsWith('.js'));
        for (const file of files) {
             const event = require(path.join(eventsPath, folder, file));
             if (event.once) {
                client.once(event.name, (...args) => event.execute(...args));
            } else {
                client.on(event.name, (...args) => event.execute(...args));
            }
        }
    }
};
`;
        await fs.writeFile(path.join(projectPath, 'handlers', 'eventHandler.js'), eventHandler);

        // slashCommandHandler.js
        const slashCommandHandler = `const fs = require('fs');
const path = require('path');
const { REST, Routes } = require('discord.js');

module.exports = async (client) => {
    const slashCommands = [];
    client.slashCommands = new Map(); // Store commands in client for execution

    const slashCommandsPath = path.join(__dirname, '../slash_commands');
    
    if (!fs.existsSync(slashCommandsPath)) return;

    // Read category folders
    const commandFolders = fs.readdirSync(slashCommandsPath).filter(file => fs.statSync(path.join(slashCommandsPath, file)).isDirectory());

    for (const folder of commandFolders) {
        const commandsPath = path.join(slashCommandsPath, folder);
        const commandFiles = fs.readdirSync(commandsPath).filter(file => file.endsWith('.js'));

        for (const file of commandFiles) {
            const filePath = path.join(commandsPath, file);
            const command = require(filePath);

            // Check for 'data' and ('execute' OR 'run')
            if ('data' in command && ('execute' in command || 'run' in command)) {
                client.slashCommands.set(command.data.name, command);
                slashCommands.push(command.data.toJSON());
            } else {
                console.log(\`[WARNING] The command at \${filePath} is missing a required "data" or "execute/run" property.\`);
            }
        }
    }

    // Also check root folder for commands not in categories
    const rootCommandFiles = fs.readdirSync(slashCommandsPath).filter(file => file.endsWith('.js'));
    for (const file of rootCommandFiles) {
        const filePath = path.join(slashCommandsPath, file);
        const command = require(filePath);
        if ('data' in command && ('execute' in command || 'run' in command)) {
            client.slashCommands.set(command.data.name, command);
            slashCommands.push(command.data.toJSON());
        }
    }

    if (!process.env.DISCORD_TOKEN || !process.env.CLIENT_ID) {
        console.warn("Missing DISCORD_TOKEN or CLIENT_ID in .env, skipping command registration.");
        return;
    }

    const rest = new REST({ version: '10' }).setToken(process.env.DISCORD_TOKEN);

    try {
        console.log(\`Started refreshing \${slashCommands.length} application (/) commands.\`);

        const data = await rest.put(
            Routes.applicationCommands(process.env.CLIENT_ID),
            { body: slashCommands },
        );

        console.log(\`Successfully reloaded \${data.length} application (/) commands.\`);
    } catch (error) {
        console.error(error);
    }
};
`;
        await fs.writeFile(path.join(projectPath, 'handlers', 'slashCommandHandler.js'), slashCommandHandler);

        // --- Events ---

        // onBotReady.js
        const readyGraphNodes = [
            { "inputs": {}, "outputs": {}, "controls": {}, "id": "root", "category": "Action", "data": { "_schemaId": "event/on-ready" }, "height": 120, "width": 200, "requiredInputs": {}, "validationMessages": {}, "x": 0, "y": 0, "type": "universal", "position": { "x": 100, "y": 100 }, "measured": { "width": 200, "height": 120 } }, { "inputs": {}, "outputs": {}, "controls": {}, "id": "7d591b2c-8d46-4435-bf2a-3b01d8a212e2", "category": "Action", "data": { "_schemaId": "variables/object-accessor", "property": "user.tag" }, "height": 120, "width": 200, "requiredInputs": {}, "validationMessages": {}, "x": 0, "y": 0, "type": "universal", "position": { "x": 400, "y": 240 }, "measured": { "width": 200, "height": 120 }, "selected": false, "dragging": false }, { "inputs": {}, "outputs": {}, "controls": {}, "id": "e13588ef-a7d4-4952-878e-6fb47934c4c8", "category": "Action", "data": { "_schemaId": "action/console-log" }, "height": 120, "width": 200, "requiredInputs": {}, "validationMessages": {}, "x": 0, "y": 0, "type": "universal", "position": { "x": 700, "y": 100 }, "measured": { "width": 200, "height": 120 }, "selected": false, "dragging": false }
        ];

        const readyGraphConnections = [
            { "style": { "strokeWidth": 2 }, "interactionWidth": 20, "reconnectable": true, "source": "root", "sourceHandle": "exec", "target": "e13588ef-a7d4-4952-878e-6fb47934c4c8", "targetHandle": "exec", "type": "vibrant", "animated": true, "data": { "color": "#ffffff" }, "id": "xy-edge__rootexec-e13588ef-a7d4-4952-878e-6fb47934c4c8exec" }, { "style": { "strokeWidth": 2 }, "interactionWidth": 20, "reconnectable": true, "source": "root", "sourceHandle": "client", "target": "7d591b2c-8d46-4435-bf2a-3b01d8a212e2", "targetHandle": "object", "type": "vibrant", "animated": false, "data": { "color": "#a1a1aa" }, "id": "xy-edge__rootclient-7d591b2c-8d46-4435-bf2a-3b01d8a212e2object" }, { "style": { "strokeWidth": 2 }, "interactionWidth": 20, "reconnectable": true, "source": "7d591b2c-8d46-4435-bf2a-3b01d8a212e2", "sourceHandle": "value", "target": "e13588ef-a7d4-4952-878e-6fb47934c4c8", "targetHandle": "msg", "type": "vibrant", "animated": false, "data": { "color": "#a1a1aa" }, "id": "xy-edge__7d591b2c-8d46-4435-bf2a-3b01d8a212e2value-e13588ef-a7d4-4952-878e-6fb47934c4c8msg" }
        ];

        await fs.writeFile(path.join(projectPath, 'events', 'onBotReady.railgun'), JSON.stringify({ nodes: readyGraphNodes, edges: readyGraphConnections }, null, 2));

        // Compile the starter graph
        try {
            const { nodes: reteNodes, connections: reteConnections } = ReactFlowAdapter.toCompilerData(readyGraphNodes, readyGraphConnections);
            const compiler = new Compiler({
                nodes: reteNodes,
                connections: reteConnections,
                fileType: 'event'
            });
            const compiledCode = compiler.compile();
            await fs.writeFile(path.join(projectPath, 'events', 'onBotReady.js'), compiledCode);
        } catch (err) {
            console.error("Failed to compile starter graph:", err);
        }

        // interactionCreate.js
        const interactionCreateJs = `const { Events } = require('discord.js');

module.exports = {
    name: Events.InteractionCreate,
    once: false,
    async execute(interaction) {
        if (!interaction.isChatInputCommand()) return;

        const command = interaction.client.slashCommands.get(interaction.commandName);

        if (!command) {
            console.error(\`No command matching \${interaction.commandName} was found.\`);
            return;
        }

        try {
            if (command.run) {
                // Railgun Compiler format: run(client, interaction)
                await command.run(interaction.client, interaction);
            } else if (command.execute) {
                // Standard format: execute(interaction)
                await command.execute(interaction);
            }
        } catch (error) {
            console.error(error);
            if (interaction.replied || interaction.deferred) {
                await interaction.followUp({ content: 'There was an error while executing this command!', ephemeral: true });
            } else {
                await interaction.reply({ content: 'There was an error while executing this command!', ephemeral: true });
            }
        }
    },
};
`;
        await fs.writeFile(path.join(projectPath, 'events', 'interactionCreate.js'), interactionCreateJs);

        // messageCreate.js
        const messageCreateJs = `const { Events } = require('discord.js');
const prefix = '!'; // Define prefix centrally or load from config

module.exports = {
    name: Events.MessageCreate,
    once: false,
    async execute(message) {
        if (message.author.bot || !message.content.startsWith(prefix)) return;

        const args = message.content.slice(prefix.length).trim().split(/ +/);
        const commandName = args.shift().toLowerCase();

        const command = message.client.commands.get(commandName) ||
            message.client.commands.get(message.client.aliases.get(commandName));

        if (!command) return;

        try {
            await command.execute(message, args);
        } catch (error) {
            console.error(error);
            message.reply('There was an error executing that command.');
        }
    },
};
`;
        await fs.writeFile(path.join(projectPath, 'events', 'messageCreate.js'), messageCreateJs);
    }
}
